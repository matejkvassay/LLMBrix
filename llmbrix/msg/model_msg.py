import io
from functools import cached_property

import PIL.Image
from google.genai import types

from llmbrix.msg.model_msg_segment import ModelMsgSegment
from llmbrix.msg.model_msg_segment_types import ModelMsgSegmentTypes

MODEL_ROLE_NAME = "model"


class ModelMsg(types.Content):
    """
    LLM response message.

    Note this message internally contains multiple message segments.
    These segments can be TEXT, IMAGE, TOOL_CALL, FILE, THOUGHT or AUDIO.

    You can control what modalities are allowed in generation config.

    These parts are generated by LLM in order => it can generate [TEXT, IMAGE, TEXT]

    Use `.segments` property to get a list of segments in correct order to be rendered.
    Use `.text` to get concatenation of all text segments. Useful in cases where LLM is used just to output text.
    Use `.images` to get list of PIL images.

    Note `.text` might be empty in cases where `.tool_calls` are present (model requests tool execution and waits).

    For audio beware that both audio / text segments might be present - use `.segments` to render both in correct order.

    Code generation and outputs are not supported (even though present in Gemini API).

    In order to ensure small object size and easy "Pydantic" serialization all these properties are computed in
    lazy fashion and not registered as Pydantic object attributes.

    Due to property caching this implementation sacrifices higher memory usage for lower CPU load at attribute access.
    """

    def __init__(self, parts: list[types.Part]):
        """
        Args:
            parts: Part objects from Content object returned by Gemini API.
                   See from_text() constructor to initialize from string.
        """
        super().__init__(role=MODEL_ROLE_NAME, parts=parts)

    @classmethod
    def from_text(cls, text: str):
        """
        Initialize new ModelMsg from string.
        Creates Content object with 1 "text" part.
        Use when "faking" model message.

        Args:
            text: Content of the model message.

        Returns:
            ModelMsg instance.
        """
        return cls(parts=[types.Part.from_text(text=text)])

    @cached_property
    def text(self) -> str:
        """
        Text content of message. Can be empty string if not generated by LLM (e.g. tool call is required)
        Returns: str text of message.
        """
        return "".join(s["content"] for s in self.get_segments_by_type(ModelMsgSegmentTypes.TEXT))

    @cached_property
    def thought(self) -> str:
        """
        Internal reasoning thoughts of the LLM. Can be empty if no thinking was done.

        Returns: str reasoning of LLM.
        """
        return "".join(s["content"] for s in self.get_segments_by_type(ModelMsgSegmentTypes.THOUGHT))

    @cached_property
    def tool_calls(self) -> list[types.FunctionCall]:
        """
        List of function calls.

        Returns: list of FunctionCall objects
        """
        return [s["content"] for s in self.get_segments_by_type(ModelMsgSegmentTypes.TOOL_CALL)]

    @cached_property
    def images(self) -> list[PIL.Image.Image]:
        """
        List of PIL images included with LLM response.

        Returns: list of PIL images.
        """
        return [s["content"] for s in self.get_segments_by_type(ModelMsgSegmentTypes.IMAGE)]

    @cached_property
    def segments(self) -> list[ModelMsgSegment]:
        """
        List of message segments to be rendered in narrative order.

        E.g. LLM may choose to first generate text, then provide image and then explain further via another
        text segment.

        Returns: list of model message segments.
        """
        segments = []
        for part in self.parts:
            if part.thought:
                if part.text:
                    segments.append(
                        ModelMsgSegment(type=ModelMsgSegmentTypes.THOUGHT, content=part.text, mime_type=None)
                    )
            elif part.text:
                segments.append(ModelMsgSegment(type=ModelMsgSegmentTypes.TEXT, content=part.text, mime_type=None))
            elif part.inline_data:
                mime = part.inline_data.mime_type
                data = part.inline_data.data
                if mime.startswith("image/"):
                    image = PIL.Image.open(io.BytesIO(data))
                    segments.append(ModelMsgSegment(type=ModelMsgSegmentTypes.IMAGE, content=image, mime_type=mime))
                elif mime.startswith("audio/"):
                    segments.append(ModelMsgSegment(type=ModelMsgSegmentTypes.AUDIO, content=data, mime_type=mime))
            elif part.function_call:
                segments.append(
                    ModelMsgSegment(type=ModelMsgSegmentTypes.TOOL_CALL, content=part.function_call, mime_type=None)
                )
        return segments

    def get_segments_by_type(self, segment_type: ModelMsgSegmentTypes) -> list[ModelMsgSegment]:
        """
        Get list of segments of given type.

        Args:
            segment_type: Type of segments to return.

        Returns: list of ModelMsgSegment objects.
        """
        return [s for s in self.segments if s["type"] == segment_type.value]
